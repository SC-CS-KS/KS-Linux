# 磁盘 I/O

## I/O 读写的类型
* 大 / 小块 I/O
```md
指的是控制器指令中给出的连续读出扇区数目的多少。
如果数目较多，如 64，128 等，我们可以认为是大块 I/O；反之，如果很小，比如 4，8，我们就会认为是小块 I/O，
实际上，在大块和小块 I/O 之间，没有明确的界限。
```
* 连续 / 随机 I/O
```md
连续 I/O 指的是本次 I/O 给出的初始扇区地址和上一次 I/O 的结束扇区地址是完全连续或者相隔不多的。
反之，如果相差很大，则算作一次随机 I/O
```
```md
连续 I/O 比随机 I/O 效率高的原因是：
在做连续 I/O 的时候，磁头几乎不用换道，或者换道的时间很短；
而对于随机 I/O，如果这个 I/O 很多的话，会导致磁头不停地换道，造成效率的极大降低。
```
* 顺序 / 并发 I/O
```md
并发 I/O 就是指向一块磁盘发出一条 I/O 指令后，不必等待它回应，接着向另外一块磁盘发 I/O 指令。
对于具有条带性的 RAID（LUN），对其进行的 I/O 操作是并发的，例如：raid 0+1(1+0),raid5 等。
反之则为顺序 I/O。
```
## 分层模型
![](../../pic/IO-Layer.png)
### 虚拟文件系统层（VFS Layer）
```md
VFS（Virtual File System）虚拟文件系统是一种软件机制，
更确切的说扮演着文件系统管理者的角色，与它相关的数据结构只存在于物理内存当中。
```
```md
它的作用是：屏蔽下层具体文件系统操作的差异，为上层的操作提供一个统一的接口。
正是因为有了这个层次，Linux中允许众多不同的文件系统共存并且对文件的操作可以跨文件系统而执行。
```
```md
VFS中包含着向物理文件系统转换的一系列数据结构，如VFS超级块、VFS的 Inode、各种操作函数的转换入口等。
Linux 中 VFS依靠四个主要的数据结构来描述其结构信息，分别为超级块、索引结点、目录项和文件对象。
```
* 超级块（Super Block）
```md
超级块对象表示一个文件系统。它存储一个已安装的文件系统的控制信息，
包括文件系统名称（比如Ext2）、文件系统的大小和状态、块设备的引用和元数据信息（比如空闲列表等等）。
```
```md
VFS超级块存在于内存中，它在文件系统安装时建立，并且在文件系统卸载时自动删除。
同时需要注意的是对于每个具体的文件系统来说，也有各自的超级块，它们存放于磁盘。
```
* 索引结点（Inode）
```md
索引结点对象存储了文件的相关元数据信息，例如：文件大小、设备标识符、用户标识符、用户组标识符等等。
Inode 分为两种：
一种是VFS的 Inode，一种是具体文件系统的 Inode。前者在内存中，后者在磁盘中。

所以每次其实是将磁盘中的 Inode 调进填充内存中的Inode，这样才是算使用了磁盘文件Inode。
当创建一个文件的时候，就给文件分配了一个Inode。一个Inode只对应一个实际文件，一个文件也会只有一个Inode。
```
* 目录项（Dentry）
```md
引入目录项对象的概念主要是出于方便查找文件的目的。
不同于前面的两个对象，目录项对象没有对应的磁盘数据结构，只存在于内存中。
一个路径的各个组成部分，不管是目录还是普通的文件，都是一个目录项对象。
如，在路径/home/source/test.java中，目录 /, home, source和文件 test.java都对应一个目录项对象。
VFS在查找的时候，根据一层一层的目录项找到对应的每个目录项的Inode，那么沿着目录项进行操作就可以找到最终的文件。
```
* 文件对象（File）
```md
文件对象描述的是进程已经打开的文件。
因为一个文件可以被多个进程打开，所以一个文件可以存在多个文件对象。
一个文件对应的文件对象可能不是惟一的，但是其对应的索引节点和目录项对象肯定是惟一的。
```
### Page Cache层
```md
引入 Cache 层的目的是为了提高Linux操作系统对磁盘访问的性能。
```
```md
在Linux的实现中，文件Cache分为两个层面，一是Page Cache，另一个Buffer Cache，每一个 Page Cache 包含若干 Buffer Cache。
Page Cache主要用来作为文件系统上的文件数据的缓存来用，尤其是针对当进程对文件有read/write操作的时候。
Buffer Cache则主要是设计用来在系统对块设备进行读写的时候，对块进行数据缓存的系统来使用。
```
```md
磁盘Cache有两大功能：预读和回写
```
* 预读
```md
对于每个文件的第一个读请求，系统读入所请求的页面并读入紧随其后的少数几个页面（通常是三个页面），这时的预读称为同步预读。

对于第二次读请求，如果所读页面不在Cache中，即不在前次预读的页中，则表明文件访问不是顺序访问，系统继续采用同步预读；
如果所读页面在Cache中，则表明前次预读命中，操作系统把预读页的大小扩大一倍，此时预读过程是异步的，
应用程序可以不等预读完成即可返回，只要后台慢慢读页面即可，这时的预读称为异步预读。
```
* 回写
```md
回写是通过暂时将数据存在Cache里，然后统一异步写到磁盘中。
通过这种异步的数据I/O模式解决了程序中的计算速度和数据存储速度不匹配的鸿沟，
减少了访问底层存储介质的次数，使存储系统的性能大大提高。
```
* * 什么时候开始回写呢？
```md
1. 在空闲内存低于一个特定的阈值时，内核必须将脏页写回磁盘，以便释放内存。
2. 当脏页在内存中驻留超过一定的阈值时，内核必须将超时的脏页写会磁盘，以确保脏页不会无限期地驻留在内存中。
```
* * 什么时候停止写数据？
```md
1. 已经有指定的最小数目的页被写回到磁盘。
2. 空闲内存页已经回升，超过了阈值。
```
* * Linux 实现
```md
Linux 2.6.32内核之后，放弃了原有的 pdflush 机制，改成了 bdi_writeback 机制。

bdi_writeback 机制主要解决了原有 fdflush机 制存在的一个问题：
在多磁盘的系统中，pdflush 管理了所有磁盘的 Cache，从而导致一定程度的I/O瓶颈。

bdi_writeback 机制为每个磁盘都创建了一个线程，专门负责这个磁盘的Page Cache的刷新工作，
从而实现了每个磁盘的数据刷新在线程级的分离，提高了I/O性能。
```
* * 缺陷
```md
回写机制存在的问题是回写不及时引发数据丢失（可由 sync| fsync 解决），回写期间读I/O性能很差。
```
### 通用块层
```md
主要工作是：
接收上层发出的磁盘请求，并最终发出I/O请求。
该层隐藏了底层硬件块设备的特性，为块设备提供了一个通用的抽象视图。
```
```md
对于VFS和具体的文件系统来说，块（Block）是基本的数据传输单元，当内核访问文件的数据时，它首先从磁盘上读取一个块。
但是对于磁盘来说，扇区是最小的可寻址单元，块设备无法对比它还小的单元进行寻址和操作。
由于扇区是磁盘的最小可寻址单元，所以块不能比扇区还小，只能整数倍于扇区大小，即一个块对应磁盘上的一个或多个扇区。
一般来说，块大小是2的整数倍，而且由于Page Cache层的最小单元是页（Page），所以块大小不能超过一页的长度。
```
```md
大多情况下，数据的传输通过DMA方式。
现在的磁盘控制器支持“分散/聚合”DMA操作，这种模式下，数据传输可以在多个非连续的内存区域中进行。
为了利用“分散/聚合”DMA操作，块设备驱动必须能处理被称为段（segments）的数据单元。
一个段就是一个内存页面或一个页面的部分，它包含磁盘上相邻扇区的数据。
```
```md
通用块层是粘合所有上层和底层的部分，一个页的磁盘数据布局如下图所示：
```
![](../z_pic/page.png)

### I/O调度层
```md
I/O调度层的功能是管理块设备的请求队列。即接收通用块层发出的I/O请求，缓存请求并试图合并相邻的请求。
并根据设置好的调度算法，回调驱动层提供的请求处理函数，以处理具体的I/O请求。
```
```md
Linux 实现了几种I/O调度算法，算法基本思想就是通过合并和排序I/O请求队列中的请求，
以此大大降低所需的磁盘寻道时间，从而提高整体I/O性能。
```
#### I/O调度算法
* Noop调度算法（No Operation）
* CFQ（完全公正排队I/O调度算法）
* DeadLine（截止时间调度算法）
* AS预测调度算法

```md
在许多的开源框架如Kafka、HBase中，都通过追加写的方式来尽可能的将随机I/O转换为顺序 I/O，
以此来降低寻址时间和旋转延时，从而最大限度的提高 IOPS。
```
### 块设备驱动层
```md
驱动层中的驱动程序对应具体的物理块设备。它从上层中取出I/O请求，并根据该I/O请求中指定的信息，
通过向具体块设备的设备控制器发送命令的方式，来操纵设备传输数据。
```

## 流程
![](../z_pic/disk-IO.png)

## [性能](https://github.com/SunnnyChan/knowledge-Sys-of-Testing/blob/master/perf/Linux/disk)
